// =============================================================================
// Auth service — business logic for register, login, refresh, logout.
//
// This layer owns:
//   - Org creation with hashed password            (register)
//   - Credential verification + token issuance     (login)
//   - Access token rotation via refresh token      (refresh)
//   - Soft-invalidation of refresh token           (logout)
//
// SPEC Risk R6 (architecture analysis — refresh token revocation):
//   Without a dedicated refresh_tokens table (not in SPEC schema), true
//   server-side revocation is not possible. We implement a best-effort
//   in-memory revocation Set.
//
//   ⚠ LIMITATION: This Set is lost on server restart. For production,
//   replace with a Redis SET with TTL matching the token expiry (7d).
//   The interface (invalidateRefreshToken / isRefreshTokenRevoked) is
//   already abstracted so the swap requires editing only this file.
// =============================================================================

import prisma from '../lib/prisma';
import { hashPassword, verifyPassword } from '../utils/hash';
import { signAccessToken, signRefreshToken, verifyRefreshToken } from '../utils/jwt';
import { AppError } from '../middleware/errorHandler';

// ─── In-memory revocation store (see R6 note above) ──────────────────────────
const revokedRefreshTokens = new Set<string>();

function invalidateRefreshToken(token: string): void {
    revokedRefreshTokens.add(token);
}

function isRefreshTokenRevoked(token: string): boolean {
    return revokedRefreshTokens.has(token);
}

// ─── Register ─────────────────────────────────────────────────────────────────

export interface RegisterInput {
    name: string;
    email: string;
    password: string;
}

export interface AuthResult {
    accessToken: string;
    refreshToken: string;
    org: { id: string; name: string; email: string };
}

/**
 * Create a new organization (tenant) account.
 *
 * Critical invariants:
 *   - orgId is GENERATED by the database — never accepted from caller.
 *   - password is hashed before storage — plain text never written to DB.
 *   - email uniqueness enforced by DB constraint (SPEC § 2.3); we catch
 *     Prisma P2002 and convert to a user-facing AppError.
 */
export async function registerOrg(input: RegisterInput): Promise<AuthResult> {
    const { name, email, password } = input;

    // Reject obviously weak passwords before touching the DB or running bcrypt
    if (password.length < 8) {
        throw new AppError(400, 'WEAK_PASSWORD', 'Password must be at least 8 characters');
    }

    const passwordHash = await hashPassword(password);

    let org: { id: string; name: string; email: string };

    try {
        org = await prisma.organization.create({
            data: { name, email, passwordHash },
            select: { id: true, name: true, email: true },
        });
    } catch (err: unknown) {
        // Prisma unique constraint violation — email already registered
        if (
            typeof err === 'object' &&
            err !== null &&
            'code' in err &&
            (err as { code: string }).code === 'P2002'
        ) {
            throw new AppError(409, 'EMAIL_ALREADY_REGISTERED', 'Email is already registered');
        }
        throw err;
    }

    // Issue token pair immediately after registration — no separate login step needed
    const accessToken = signAccessToken(org.id, org.email);
    const refreshToken = signRefreshToken(org.id);

    return { accessToken, refreshToken, org };
}

// ─── Login ────────────────────────────────────────────────────────────────────

export interface LoginInput {
    email: string;
    password: string;
}

/**
 * Authenticate an existing organization and issue a JWT pair.
 *
 * Security: if the org is not found OR the password is wrong, we return the
 * same error message to prevent email enumeration attacks.
 */
export async function loginOrg(input: LoginInput): Promise<AuthResult> {
    const { email, password } = input;

    const org = await prisma.organization.findUnique({
        where: { email },
        select: { id: true, name: true, email: true, passwordHash: true },
    });

    // Constant-time: run bcrypt even on not-found to prevent timing attacks
    const dummyHash = '$2a$12$invalidhashpaddingtoensureconstanttimebehaviourXXXXXXXX';
    const isValid = await verifyPassword(password, org?.passwordHash ?? dummyHash);

    if (!org || !isValid) {
        // Same message for both "org not found" and "wrong password" — no enumeration
        throw new AppError(401, 'INVALID_CREDENTIALS', 'Invalid email or password');
    }

    const accessToken = signAccessToken(org.id, org.email);
    const refreshToken = signRefreshToken(org.id);

    return {
        accessToken,
        refreshToken,
        org: { id: org.id, name: org.name, email: org.email },
    };
}

// ─── Refresh ──────────────────────────────────────────────────────────────────

export interface RefreshResult {
    accessToken: string;
}

/**
 * Issue a new access token using a valid refresh token.
 *
 * Does NOT rotate the refresh token itself — rotation is a future improvement
 * that requires the refresh_tokens DB table (not in current SPEC schema).
 */
export async function refreshAccessToken(refreshToken: string): Promise<RefreshResult> {
    // Check against revocation list first (catches logout'd tokens)
    if (isRefreshTokenRevoked(refreshToken)) {
        throw new AppError(401, 'TOKEN_REVOKED', 'Refresh token has been revoked. Please log in again.');
    }

    // Verify signature and expiry
    const payload = verifyRefreshToken(refreshToken); // throws AppError if invalid

    // Verify that the org referenced in the token still exists in the DB
    // (handles the edge case where an org was deleted post-issuance — SPEC R7 partial mitigate)
    const org = await prisma.organization.findUnique({
        where: { id: payload.orgId },
        select: { id: true, email: true },
    });

    if (!org) {
        throw new AppError(401, 'ORG_NOT_FOUND', 'Organization no longer exists');
    }

    const accessToken = signAccessToken(org.id, org.email);
    return { accessToken };
}

// ─── Logout ───────────────────────────────────────────────────────────────────

/**
 * Soft-invalidate the refresh token.
 *
 * The access token (1h) continues to work until natural expiry — this is an
 * accepted trade-off with stateless JWTs. The refresh token is revoked
 * immediately, preventing any further access token renewals.
 *
 * R6 note: in-memory only — lost on restart. See file header.
 */
export async function logoutOrg(refreshToken: string): Promise<void> {
    // Validate the token structure before adding to revocation list.
    // This prevents an attacker from flooding the Set with garbage values.
    try {
        verifyRefreshToken(refreshToken);
    } catch {
        // If the token is already invalid/expired, logout still succeeds silently.
        // Do not leak whether the token was valid.
    }

    invalidateRefreshToken(refreshToken);
}
