// =============================================================================
// Prisma Schema — Mini AI-HRMS
// Source of truth: SPEC.md § 2.3 (Database Schema)
//
// Rules enforced:
//   - Every table / column maps exactly to the SQL definition in the SPEC.
//   - All FK relations are explicit (with onDelete behaviour matching the spec).
//   - All five indexes cited in the SPEC are reproduced as @@index directives.
//   - No fields are added beyond what the SPEC defines.
//   - Field naming: camelCase in Prisma, snake_case via @map / @@map for DB.
//
// RBAC addition (AUTH_SYSTEM.md):
//   - Role enum  — ADMIN | EMPLOYEE (replaces unconstrained VARCHAR on Employee)
//   - User model — owns credentials and session metadata; bridges Org + Employee
// =============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─────────────────────────────────────────────────────────────────────────────
// ROLE ENUM
// Replaces the unconstrained VARCHAR(100) used on Employee.role.
// Enforced at the Postgres type level — no CHECK constraint needed.
// ─────────────────────────────────────────────────────────────────────────────
enum Role {
  ADMIN
  EMPLOYEE
}

// ─────────────────────────────────────────────────────────────────────────────
// ORGANIZATIONS  (Tenants)
// SPEC: organizations table
// ─────────────────────────────────────────────────────────────────────────────
model Organization {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String   @db.VarChar(255)
  email     String   @unique @db.VarChar(255)
  // password_hash column removed — credentials live exclusively on the User row.
  // Migration: 20260223000000_drop_org_password_hash
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()

  // Relations
  users            User[]
  employees        Employee[]
  tasks            Task[]
  blockchainLogs   BlockchainLog[]
  performanceLogs  PerformanceLog[]

  @@map("organizations")
}

// ─────────────────────────────────────────────────────────────────────────────
// USER  (Auth identity — AUTH_SYSTEM.md)
//
// Owns credentials and session state.  Separate from Employee so that auth
// concerns are decoupled from business-logic profile data.
//
// Key design decisions:
//   - employeeId is optional + unique: a User may exist before an Employee
//     profile is created (e.g. org owner at registration time), and each
//     Employee profile maps to at most one User.
//   - role is the Role enum, enforced at the Postgres type level.
//   - tokenVersion is incremented on password-change or explicit logout to
//     invalidate all outstanding JWTs without a token blocklist.
//   - email is globally unique across all orgs (unlike Employee.email which
//     is unique per-org only); this is the canonical login identifier.
// ─────────────────────────────────────────────────────────────────────────────
model User {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orgId        String   @map("org_id") @db.Uuid
  employeeId   String?  @unique @map("employee_id") @db.Uuid
  email        String   @unique @db.VarChar(255)
  passwordHash String   @map("password_hash") @db.Text
  role         Role     @default(EMPLOYEE)
  tokenVersion Int      @default(0) @map("token_version")
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz()

  // FK: org_id → organizations(id) ON DELETE CASCADE
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // FK: employee_id → employees(id) ON DELETE SET NULL
  // Optional 1-to-1: a User can exist without an Employee profile, and
  // deleting an Employee profile does not destroy the auth User.
  employee Employee? @relation(fields: [employeeId], references: [id], onDelete: SetNull)

  // Fast lookup by org — used when listing org members or invalidating all
  // sessions for a tenant.
  @@index([orgId], name: "idx_users_org")

  // Composite: (org_id, email) for login lookup scoped to a tenant where needed.
  @@index([orgId, email], name: "idx_users_org_email")

  @@map("users")
}

// ─────────────────────────────────────────────────────────────────────────────
// EMPLOYEES
// SPEC: employees table
//   - Unique constraint: (org_id, email)
//   - skills: TEXT[] in PostgreSQL
//   - wallet_address: optional, max 42 chars (EVM address length)
//   - is_active: soft-delete flag
// ─────────────────────────────────────────────────────────────────────────────
model Employee {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orgId         String   @map("org_id") @db.Uuid
  name          String   @db.VarChar(255)
  email         String   @db.VarChar(255)
  passwordHash  String   @map("password_hash") @db.Text
  // jobTitle: free-text job title (e.g. "Senior Engineer", "Designer").
  // Renamed from `role` to avoid confusion with User.role (the ADMIN|EMPLOYEE
  // RBAC enum).  Migration: 20260223000001_rename_employee_role_to_job_title
  // Nullable — not every employee has a formal job title at creation time.
  jobTitle      String?  @map("job_title") @db.VarChar(100)
  department    String?  @db.VarChar(100)
  skills        String[] // maps to TEXT[] in PostgreSQL
  walletAddress String?  @map("wallet_address") @db.VarChar(42)
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz()

  // FK: org_id → organizations(id) ON DELETE CASCADE
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Relations
  tasks           Task[]
  performanceLogs PerformanceLog[]
  user            User?

  // SPEC: UNIQUE(org_id, email)
  @@unique([orgId, email])
  // SPEC: CREATE INDEX idx_employees_org ON employees(org_id)
  @@index([orgId], name: "idx_employees_org")
  @@map("employees")
}

// ─────────────────────────────────────────────────────────────────────────────
// TASKS
// SPEC: tasks table
//   - priority:          VARCHAR(20) DEFAULT 'medium'  — low | medium | high
//   - status:            VARCHAR(20) DEFAULT 'assigned' — assigned | in_progress | completed
//   - complexity_score:  INTEGER DEFAULT 3             — 1 (simple) to 5 (complex)
//   - required_skills:   TEXT[]
//   - due_date / completed_at: optional
// ─────────────────────────────────────────────────────────────────────────────
model Task {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orgId           String    @map("org_id") @db.Uuid
  assignedTo      String?   @map("assigned_to") @db.Uuid
  title           String    @db.VarChar(255)
  description     String?   @db.Text
  priority        String    @default("medium") @db.VarChar(20)
  status          String    @default("assigned") @db.VarChar(20)
  complexityScore Int       @default(3) @map("complexity_score")
  requiredSkills  String[]  @map("required_skills")
  dueDate         DateTime? @map("due_date") @db.Timestamptz()
  completedAt     DateTime? @map("completed_at") @db.Timestamptz()
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz()

  // FK: org_id → organizations(id) ON DELETE CASCADE
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // FK: assigned_to → employees(id)  (no CASCADE — employee soft-deleted, task remains)
  employee Employee? @relation(fields: [assignedTo], references: [id])

  // Relations
  blockchainLogs BlockchainLog[]

  // SPEC indexes:
  //   CREATE INDEX idx_tasks_org      ON tasks(org_id)
  //   CREATE INDEX idx_tasks_assigned ON tasks(assigned_to)
  //   CREATE INDEX idx_tasks_status   ON tasks(status)
  @@index([orgId], name: "idx_tasks_org")
  @@index([assignedTo], name: "idx_tasks_assigned")
  @@index([status], name: "idx_tasks_status")

  // Performance: (org_id, status) lookup for dashboard aggregates
  @@index([orgId, status])

  @@map("tasks")
}

// ─────────────────────────────────────────────────────────────────────────────
// PERFORMANCE LOGS  (AI-generated scores)
// SPEC: performance_logs table
//   - score:     NUMERIC(5,2)  — e.g. 84.50
//   - breakdown: JSONB         — { completionRate, onTimeRate, avgComplexity, … }
// Non-SPEC addition (CRITICAL-1 fix from architecture audit):
//   - org_id: added to enable defence-in-depth tenant scoping on every query.
//     Backfill SQL in migration 0002_add_org_id_to_performance_logs.
// ─────────────────────────────────────────────────────────────────────────────
model PerformanceLog {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orgId      String   @map("org_id") @db.Uuid
  employeeId String   @map("employee_id") @db.Uuid
  score      Decimal? @db.Decimal(5, 2)
  breakdown  Json?    // maps to JSONB in PostgreSQL
  computedAt DateTime @default(now()) @map("computed_at") @db.Timestamptz()

  // FK: org_id → organizations(id) ON DELETE CASCADE
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // FK: employee_id → employees(id) ON DELETE CASCADE
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  // SPEC: CREATE INDEX idx_perf_employee ON performance_logs(employee_id)
  @@index([employeeId], name: "idx_perf_employee")
  // Tenant-only lookups (invalidation, audit scans)
  @@index([orgId], name: "idx_perf_org")
  // Primary query pattern: WHERE org_id = ? AND employee_id = ? ORDER BY computed_at DESC
  // Covers date-ranged score history and latest-score lookups without a heap scan.
  @@index([orgId, employeeId, computedAt(sort: Desc)], name: "idx_perf_org_employee_date")

  // Performance: score trend/history lookups for a specific employee
  @@index([employeeId, computedAt(sort: Desc)])

  @@map("performance_logs")
}

// ─────────────────────────────────────────────────────────────────────────────
// BLOCKCHAIN LOGS
// SPEC: blockchain_logs table
//   - tx_hash:    VARCHAR(66)  — 0x + 64 hex chars (Ethereum tx hash length)
//   - event_type: VARCHAR(50) DEFAULT 'task_completed'
// ─────────────────────────────────────────────────────────────────────────────
model BlockchainLog {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orgId      String   @map("org_id") @db.Uuid
  taskId     String   @map("task_id") @db.Uuid
  txHash     String   @map("tx_hash") @db.VarChar(66)
  eventType  String   @default("task_completed") @map("event_type") @db.VarChar(50)
  loggedAt   DateTime @default(now()) @map("logged_at") @db.Timestamptz()

  // FK: org_id → organizations(id)   (no CASCADE — logs are audit records, preserve on org ops)
  organization Organization @relation(fields: [orgId], references: [id])

  // FK: task_id → tasks(id)           (no CASCADE — same audit-preservation rationale)
  task Task @relation(fields: [taskId], references: [id])

  // Performance: audit trail lookups
  @@index([orgId])
  @@index([taskId])

  @@map("blockchain_logs")
}

// ─────────────────────────────────────────────────────────────────────────────
// SCORING JOBS  (Postgres-backed durable job queue)
//
// Replaces the Redis/BullMQ queue and the in-process setImmediate dispatcher.
// Jobs survive server restarts because they live in Postgres alongside the
// rest of the application data — no separate Redis dependency required.
//
// Worker pattern: SELECT … FOR UPDATE SKIP LOCKED
//   The worker polls for pending jobs, locks the row atomically, and processes
//   it.  SKIP LOCKED means multiple worker processes/threads never race on the
//   same row.  After success the row is deleted; after final failure it is
//   moved to status='failed' for post-mortem inspection.
//
// Deduplication: jobKey = 'score:task:<taskId>' — UNIQUE constraint means a
//   second enqueue for the same task is silently dropped (INSERT … ON CONFLICT
//   DO NOTHING).
// ─────────────────────────────────────────────────────────────────────────────
model ScoringJob {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  jobKey      String   @unique @map("job_key") @db.VarChar(255)   // deduplication key
  queue       String   @default("scoring") @db.VarChar(100)
  payload     Json                                                  // ScoreJobPayload
  status      String   @default("pending") @db.VarChar(20)         // pending | processing | failed
  attempts    Int      @default(0)
  maxAttempts Int      @default(3) @map("max_attempts")
  runAt       DateTime @default(now()) @map("run_at") @db.Timestamptz()  // earliest execution time
  failedAt    DateTime? @map("failed_at") @db.Timestamptz()
  errorMsg    String?  @map("error_msg") @db.Text
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz()

  // Worker poll index: WHERE status='pending' AND run_at <= now() ORDER BY run_at ASC
  @@index([status, runAt], name: "idx_scoring_jobs_poll")
  @@index([queue, status], name: "idx_scoring_jobs_queue_status")

  @@map("scoring_jobs")
}
